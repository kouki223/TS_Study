**TypeScript について読んで学ぶ**

- 値・型・変数

  - 変数宣言=>variable declaration

    - let
      - 再代入可能な変数
        - 初期値が存在せずに変数の宣言を実行する事ができる
    - const
      - 再代入禁止の変数
        - 可変オブジェクト(ミュータブルな値)を保護しない
          - 変数自体への再代入は禁止されているが、オブジェクトのプロパティに対する値の代入は保護しない

  - let と const の使い分け

    - 基本的に使う変数の宣言は const を使用する
      - let を使用しなければならない理由がある場合に let を使用する

  - 読み取り専用にプロパティを変化させる

    - readonly
      - プロパティの前に記述する事でプロパティの変更もできなくなる
        - 再帰的ではないプロパティのため指定したプロパティのみに影響を与える
    - const アサーション
      - 変数宣言時に末尾に as const をつけるとリテラル型のままで readonly にしてくれる
    - readonly と const アサテーションの違い
      - const アサテーションは再帰的に readonly にする事ができる

  - 変数宣言の型注釈

    - 変数に値を代入する際にどんな型の値が代入されるか？を指定する事ができる

  - ver

    - ES2015 において var の問題点を解決するために let と const が導入された
      - var にはいくつかの問題点が存在する
        - 同名の変数宣言
          - let と const では禁止となっている同名の変数宣言が実施できてしまう
            - 既存の変数の書き換えを行なってしまい想定外の挙動の可能性がある
        - グローバル変数の書き換え
          - var がグローバルスコープで定義された時には window オブジェクトのプロパティとして定義される
            - 既存のプロパティを上書きしてしまう可能性がある
              - 標準 API などのプロパティなどを書き換えてしまうと予期していない挙動が生まれてしまう
                - let や const はグローバルスコープには定義されないためその点が解決されている
                  - 例：window.innerWidth
                    - let で innerWidth が定義されてしまうとウィンドウの幅が一定で帰ってきてしまう
        - 変数の巻き上げ
          - var で定義された変数はスコープの先頭で定義される
            - そのため、変数宣言の前に変数の呼び出しが可能になるという仕様が起きうる
              - 意図しない undefined を呼び出してしまう事になってしまう
          - 変数の初期化
            - 変数の巻き上げは let,const でも起こっているが変数の巻き上げが起きても変数の初期化を行わないので参照エラーになる
              - 変数の宣言時に変数の初期化を実行するのが let,const である
        - スコープ
          - var で宣言された変数のスコープにおいては、関数として扱われる
            - {}リテラルを使って定義した場合でも関数として実行されてスコープ外の変数に対して影響を与える
              - let や const はスコープ内で定義された場合でもブロックとして扱われるためスコープ外の変数に対して影響を与えない

  - 型推論(type inference)

    - コンパイラが自動で型を判別してくれる機能

      - 型注釈を記載せずに型の不一致によるコンパイルエラーを吐いてくれるようになる
        - 型注釈を記載しなくて良いためコード量の減少や、記載漏れなどによる型の不一致などを防いでくれる

    - 型推論と動的型付け言語の違い
      - 動的型付け言語
        - インタプリンタ言語に多くみられて、一行づつソースコードを実行する方法
      - 違い
        - 型を決定するタイミングが違う
          - 型推論はプログラマーが型を決定しており、動的型付け言語はコードの実行時に型を自動で推測し決定している
            - 型推論を使用する言語においては静的型付け言語が多いがコンパイル時に型は静的に決定されており、型が変わる場合にはエラーを吐く
            - インタプリンタ言語においては、コードの実行時に型が決定さえるためミュータブルな変数において文字列＝＞数値と異なる型でも実行する事が可能になる

  - JS におけるデータ型
    - オブジェクトとプリミティブ型の 2 種類に分ける事ができる
      - オブジェクト
        - ミュータブルな特性を持つデータ型
          - JS においては一部のプリミティブ型を除いて全てがオブジェクトと考える事ができる
      - プリミティブ型
        - イミュータブルな特定を持つデータ型
        - プロパティを持たない
          - null と undefined はプロパティを持たない
    - 自動 BOX 化＝＞オートボクシング(autoboxing)
      - プリミティブ型を自動的にオブジェクトへ変換する機能が JS にはありそれを自動 BOX 化と呼ぶ
    - オブジェクトとして判定されないプリミティブ型
      - boolean 型(論理型): true または false の真偽値
        - リテラル
          - true or false を使って表す
        - 型注釈
          - : boolean のように注釈する
      - number 型(数値型): 0 や 0.1 のような数値。
        - リテラル
          - 数値リテラルは見たまんまを記載する
            - 例：1000、-1000、0.1、0.05、.5 など　 0.1 === .1、5 === 5.となる
          - 2 進数、8 進数、16 進数なども記載できる
            - 2 進数は数値の前に　 0b 　を記述する
            - 8 進数は数値の前に　 0o 　を記述
            - 16 進数は数値の前に　 0x 　を記述する
        - 区切り文字
          - アンダースコアを使って区切り文字とする事ができる
            - 注意点
              - 先頭
              - 末尾
              - 小数点の前後
              - 連続で 2 個以上置くこと
                - 上記は禁止になっている
        - プロパティアクセス
          - 小数点の.とアクセサプロパティの.が判別できないた mw
            - 数値をい()で囲む or ..のようにドットを 2 個使うなどの対処法がある
        - 型注釈
          - : number を使用する
            - 似ている型に Number が存在するが、別物になるため注意が必要
        - 特殊な数値
          - NaN
            - 非数(not-a-number)を表す変数
              - Number.isNaN を実行する事で値が NaN であるかを判別できる
                - 等号符では必ず、false になるため注意が必要
          - Infinity
            - 無限大を表す変数
              - 0 を 1 で割るなどの処理を行った時に出現する
      - string 型(文字列型): "Hello World"のような文字列。
        - リテラル
        - 型注釈
      - undefined 型: 値が未定義であることを表す型。
        - リテラル
        - 型注釈
      - null 型: 値がないことを表す型。
        - リテラル
        - 型注釈
      - symbol 型(シンボル型): 一意で不変の値。
        - リテラル
        - 型注釈
      - bigint 型(長整数型): 9007199254740992n のような number 型では扱えない大きな整数型。
        - リテラル
        - 型注釈
